import {writeFile} from "node:fs/promises";
import path, {dirname, join} from "node:path";
import {globby} from "globby";

// async function cleanIndex(cwd, excluded) {
//   const patterns = [
//     "**/index.ts",
//     ...excluded
//   ];
//
//   const files = await globby(patterns, {
//     cwd: cwd
//   });
//
//   return Promise.all(files.map((file) => fs.unlink(join(cwd, file))));
// }

export async function generateBarrels({exclude, directory, cwd}) {
  const excluded = exclude
    .map((path) => `!${path}`)
    .concat(directory.map((path) => `!${path}/index.ts`));

  const directories = (
    await globby(directory.map((d) => {
        return join(d, "*");
      }),
      {
        cwd
      })
  ).reduce((set, file) => {
    return set.add(dirname(file));
  }, new Set());

  const promises = [...directories.keys()].map(async (directory) => {
    const baseIndex = join(cwd, directory?.path ?? directory);

    const files = await globby(["**/*.{ts,tsx}", "!index.{ts,tsx}", ...excluded], {
      cwd: path.join(cwd, directory)
    });

    const exports = files
      .sort((a, b) => a.localeCompare(b))
      .map((file) => {
        // TODO set .js after all configuration are ok to resolve .js
        return `export * from "./${file.replace(".ts", ".js")}";`;
      });

    const content = ["/**", " * @file Automatically generated by @tsed/barrels.", " */", ...exports];

    await writeFile(join(baseIndex, "index.ts"), content.join("\n") + "\n", {encoding: "utf8"});
  });

  await Promise.all(promises);
}
